* Programming in Emacs Lisp
** 前言
** 列表处理(List Processing)
没学过的人的眼中 lisp 是一个奇怪的编程语言. 在lisp 的代码中，到处都是括号.
有些人甚至说 LISP 为 (Lots of Isolated Silly Parentheses).但是这种
说法是没有根据的. LISP 表示 LISt(列表) Processing(处理). 这种编程语言
是通过把 _lists_ 列表 和 列表的列表放到括号中处理的. 括号标记着列表的边界.

** lambda 匿名函数
   ‘lambda’ 是一个匿名函数的symbol, 每次使用匿名函数的时候你需要包括他整
   个的函数体.
   (lambda (arg) (/ arg 50))

     ((lambda (arg) (/ arg 50)) 100)
      \______________________/  \_/
                  |              |
      匿名函数          参数
** set 和 setq 设置一个变量的值。

符号的组成

每个符号可以对应四个组成部分，一是符号的名字，可以用 symbol-name 访问
。二是符号的值。符号的值可以通过 set 函数来设置，用 symbol-value 来访
问。

(set (intern "abc" foo) "I'm abc")      ; => "I'm abc"
(symbol-value (intern "abc" foo))       ; => "I'm abc"

可能大家最常见到 setq 函数，而 set 函数确很少见到。setq 可以看成是一个
宏，它可以让你用 (setq sym val) 代替 (set (quote sym) val)。事实上这也
是它名字的来源 (q 代表 quoted)。但是 setq 只能设置 obarray 里的变量，
前面这个例子中就只能用 set 函数。

有时候一个列表前面还有一个单引号.
** let 和 let* 
   'let' 创建一个 local variable （本地变量） 他会覆盖外部的 let 的变量.
   下面是一个例子

     (let ((birch 3)
           pine
           fir
           (oak 'some))
       (message
        "Here are %d variables with %s, %s, and %s value."
        birch pine fir oak))

   c-x c-e 后会messege out 
        "Here are 3 variables with nil, nil, and some value."
   
** message Hello Word
   (message "Hello Word")
** 基础知识  
   这一节介绍一下 elisp 编程中一些最基本的概念，比如如何定义函数，程序的控制结构，
   变量的使用和作用域等等。

*** 函数 (c-h f 看函数帮助)

elisp 中定义一个函数是用这样的形式：

(defun function-name (arguments-list)
  "document string"
  body)

比如：

(defun hello-world (name)
  "Say hello to user whose name is NAME." ;; here doc . 他将会显示在 c-h f 当中
  (message "Hello, %s" name))

(hello-world "haha")

在 emacs 里，当光标处于一个函数名上时，可以用 C-h f 查看这个函数的文档。比如前面这个函数，
在 *Help* 缓冲区里的文档是：

hello-world is a Lisp function.
(hello-world name)

Say hello to user whose name is name.

？？？如果你的函数是在文件中定义的。这个文档里还会给出一个链接能跳到定义的地方。？？？

要运行一个函数，最一般的方式是：

(function-name arguments-list)

比如前面这个函数：

(hello-world "Emacser")                 ; => "Hello, Emacser"

每个函数都有一个返回值。这个返回值一般是函数定义里的最后一个表达式的值。

*** 变量  (c-h v 看变量帮助) (set & setq & defvar)
elisp 里的变量使用无需象 C 语言那样进行声明，你可以用 setq 直接对一个
变量赋值。
**** setq & set

setq means set quote <=> set 'var

(setq foo "I'm foo")                    ; => "I'm foo"
(message foo)                           ; => "I'm foo"

和函数一样，你可以用 C-h v 查看一个变量的文档。比如当光标在 foo 上时用
C-h v 时，文档是这样的：

foo's value is "I'm foo"

Documentation:
Not documented as a variable.

**** defvar  (带有 here doc 的定义)

If DOCSTRING starts with *, this variable is identified as a user option.
 This means that M-x set-variable recognizes it.
 See also `user-variable-p'.
If INITVALUE is missing, SYMBOL's value is not set.

有一个特殊表达式（special form）defvar，它可以声明一个变量，一般的形式是：

(defvar variable-name value
  "document string")

它与 setq 所不同的是，如果变量在声明之前，这个变量已经有一个值的话，用defvar 
声明的变量值不会改变成声明的那个值。另一个区别是 defvar 可以为变量提供文档字符
串，当变量是在文件中定义的话，C-h v 后能给出变量定义的位置。比如：

(defvar footing "Did I have a value?"
  "*A demo variable")                    ; => foo
footing                                     ; => "I'm foo"
(defvar bar "I'm bar"
  "A demo variable named \"bar\"")      ; => bar
bar                                     ; => "I'm bar"

用 C-h v 查看 foo 的文档，可以看到它已经变成：

foo's value is "I'm foo"

Documentation:
A demo variable

由于 elisp 中函数是全局的，变量也很容易成为全局变量（因为全局变量和局部变量的
赋值都是使用 setq 函数），名字不互相冲突是很关键的。所以除了为你的函数和变量选
择一个合适的前缀之外，用 C-h f 和 C-h v 查看一下函数名和变量名有没有已经被使
用过是很关键的。

**** 局部作用域的变量 (let & let*)

如果没有局部作用域的变量，都使用全局变量，函数会相当难写。elisp 里可以
用 let 和 let* 进行局部变量的绑定。

***** let 使用的形式是：

(let (bindings)
  body)

bingdings 可以是 (var value) 这样对 var 赋初始值的形式，或者用 var 声
明一个初始值为 nil 的变量。比如：

(defun circle-area (radix)
  (let ((pi 3.1415926)
        area)
    (setq area (* pi radix radix))
    (message "半径为 %.2f 的圆面积是 %.2f" radix area)))
(circle-area 3)

C-h v 查看 area 和 pi 应该没有这两个变量。

***** let* 和 let 的使用形式完全相同，唯一的区别是在 let*声明中就能使用前面声明的变量
比如：

(defun circle-area (radix)p
  (let* ((pi 3.1415926)
         (area (* pi radix radix)))
    (message "半径为 %.2f 的圆面积是 %.2f" radix area)))

*** lambda 表达式

可能你久闻 lambda 表达式的大名了。其实依我的理解，lambda 表达式相当于
其它语言中的匿名函数。比如 perl 里的匿名函数。它的形式和 defun 是相似
的，只是没有了文档字符串：

(lambda (arguments-list)
  body)

调用 lambda 方法如下：

(funcall (lambda (name)
           (message "Hello, %s!" name)) "Emacser")

你也可以把 lambda 表达式赋值给一个变量，然后用 funcall 调用

(setq foo (lambda (name)
            (message "Hello, %s!" name)))
(funcall foo "Emacser")                   ; => "Hello, Emacser!"

lambda 表达式最常用的是作为参数传递给其它函数，比如 mapc。

*** 控制结构  (progn & if & cond & while)
**** 顺序执行 ( progn )

一般来说程序都是按表达式顺序依次执行的。这在 defun 等特殊环境中是自动进行的。但是
一般情况下都不是这样的。比如你无法用 eval-last-sexp 同时执行两个表达式，在 if 
表达式中的条件为真时执行的部分也只能运行一个表达式。这时就需要用 progn 这个特殊表
达式。它的使用形式如下：

(progn A B C ...)

它的作用就是让表达式 A, B, C 顺序执行。比如：

(progn
  (setq foo 3)
  (message "Square of %d is %d" foo (* foo foo)))
  
**** 条件判断 (if 和 cond)
***** if st
(if condition
    then
  else)
***** cond st
(cond (case1 do-when-case1)
      (case2 do-when-case2)
      ...
      (t do-when-none-meet))

***** if & conf 使用的例子:

(defun my-max (a b)
  (if (> a b)
      a b))
(my-max 3 4)                            ; => 4

(defun fib (n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (t (+ (fib (- n 1))
                 (fib (- n 2))))))
(fib 10)                                ; => 55

还有两个宏 when 和 unless，从它们的名字也就能知道它们是作什么用的。使
用这两个宏的好处是使代码可读性提高，when 能省去 if 里的 progn 结构，
unless 省去条件为真子句需要的的 nil 表达式。

**** 循环 (while)

循环使用的是 while 表达式。它的形式是：

(while condition
  body)

比如：

(defun factorial (n)
  (let ((res 1))
    (while (> n 1)
      (setq res (* res n)
            n (- n 1)))
    res))

(defun walkob (n)
   (let ((res 1))
      (while (> n 1)
        
      )
)
(factorial 10)                          ; => 3628800

*** 逻辑运算  (and or not)

条件的逻辑运算和其它语言都是很类似的，使用 and、or、not。and 和 or 也
同样具有短路性质。很多人喜欢在表达式短时，用 and 代替 when，or 代替
unless。当然这时一般不关心它们的返回值，而是在于表达式其它子句的副作用
。比如 or 经常用于设置函数的缺省值，而 and 常用于参数检查：

(defun hello-world (&optional name)
  (or name (setq name "Emacser"))
  (message "Hello, %s" name))           ; => hello-world
(hello-world)                           ; => "Hello, Emacser"
(hello-world "Ye")                      ; => "Hello, Ye"

(defun square-number-p (n)
  (and (>= n 0)
       (= (/ n (sqrt n)) (sqrt n))))
(square-number-p -1)                    ; => nil
(square-number-p 25)                    ; => t

*** 函数列表

(defun NAME ARGLIST [DOCSTRING] BODY...)
(defvar SYMBOL &optional INITVALUE DOCSTRING)
(setq SYM VAL SYM VAL ...)
(let VARLIST BODY...)
(let* VARLIST BODY...)
(lambda ARGS [DOCSTRING] [INTERACTIVE] BODY)
(progn BODY ...)
(if COND THEN ELSE...)
(cond CLAUSES...)
(when COND BODY ...)
(unless COND BODY ...)
(when COND BODY ...)
(or CONDITIONS ...)
(and CONDITIONS ...)
(not OBJECT)

** 基本数据类型之一 数字
*** 数字
**** 类型简介
    elisp 里的对象都是有类型的，而且每一个对象它们知道自己是什么类型。你得到一个变量名
之后可以用一系列检测方法来测试这个变量是什么类型（好像没有什么方法来让它说出自己是什么类型的）。
    内建的 emacs 数据类型称为:
primitive types，包括整数、浮点数、cons、 符号(symbol)、字符串、向量 (vector)、
散列表(hash-table)、subr（内建函数，比如 cons, if, and 之类 ）、 byte-code function，
和其它特殊类型，例如缓冲区（buffer）。

在开始前有必要先了解一下读入语法和输出形式。所谓读入语法是让 elisp 解释器明白输入字符所代表的对象，
你不可能让 elisp 读入 .#@!? 这样奇怪的东西还能好好工作吧（perl好像经常要受这样的折磨:)）。
简单的来说，一种数据类型有（也可能没有，比如散列表）对应的规则来让解释器产生这种数据类型，
	比如 123 产生整数 123，
	(a . b) 产生一个 cons。
所谓输出形式是解释器用产生一个字符串来表示一个数据对象。比如整数 123 的输出形式就是 123，cons
cell (a . b) 的输出形式是 (a . b)。与读入语法不同的是，数据对象都有输
出形式。比如散列表的输出可能是这样的：

#<hash-table 'eql nil 0/65 0xa7344c8>

通常一个对象的数据对象的输出形式和它的读入形式都是相同的。现在就先从简单的数据类型──数字开始吧。

**** 数字
emacs 的数字分为整数和浮点数（和 C 比没有双精度数 double）。 1， 1.+1, -1, 536870913, 0, -0 
这些都是整数。整数的范围是和机器是有关的，一般来最小范围是在 -268435456 to 268435455
（29位，-2**28 ~ 2**28-1）。可以从 most-positive-fixnum 和 most-negative-fixnum 
两个变量得到整数的范围。

你可以用多种进制来输入一个整数。比如：

     #b101100 => 44      ; 二进制
     #o54 => 44          ; 八进制
     #x2c => 44          ; 十进制

最神奇的是你可以用 2 到 36 之间任意一个数作为基数，比如：

     #24r1k => 44        ; 二十四进制

之所以最大是 36，是因为只有 0-9 和 a-z 36 个字符来表示数字。但是我想基本上不会有人会用到 emacs 
的这个特性。

1500.0, 15e2, 15.0e2, 1.5e3, 和 .15e4 都可以用来表示一个浮点数 1500.。
遵循 IEEE 标准，elisp 也有一个特殊类型的值称为 NaN (not-a-number)。你
可以用 (/ 0.0 0.0) 产生这个数。

**** 测试函数 (integerp & floatp & numberp)

整数类型测试函数是 integerp，浮点数类型测试函数是 floatp。数字类型测试用 numberp。
你可以分别运行这几个例子来试验一下：

(integerp 1.)                           ; => t
(integerp 1.0)                          ; => nil
(floatp 1.)                             ; => nil
(floatp -0.0e+NaN)                      ; => t
(numberp 1)                             ; => t

还提供一些特殊测试，比如测试是否是零的 zerop，还有非负整数测试的 wholenump。

**** 数的比较 (<, >, >=, <=, )

常用的比较操作符号是我们在其它言中都很熟悉的，比如 <, >, >=, <=，不一样的是，由于赋值是使用 
set 函数，所以 = 不再是一个赋值运算符了，而是测试数字相等符号。和其它语言类似，对于浮点数的相
等测试都是不可靠的。比如:

(setq foo (- (+ 1.0 1.0e-3) 1.0))       ; => 0.0009999999999998899
(setq bar 1.0e-3)                       ; => 0.001
(= foo bar)                             ; => nil

所以一定要确定两个浮点数是否相同，是要在一定误差内进行比较。这里给出一
个函数：

(defvar fuzz-factor 1.0e-6)
(defun approx-equal (x y)
  (or (and (= x 0) (= y 0))
      (< (/ (abs (- x y))
            (max (abs x) (abs y)))
         fuzz-factor)))
(approx-equal foo bar)                  ; => t

还有一个测试数字是否相等的函数 eql，这是函数不仅测试数字的值是否相等，还测试数字类型是否一致，比如：

(= 1.0 1)                               ; => t
(eql 1.0 1)                             ; => nil

elisp 没有 +=, -=, /=, *= 这样的命令式语言里常见符号，如果你想实现类似功能的语句，只能用赋值函数 
setq 来实现了。 /= 符号被用来作为不等于的测
试了。

**** 数的转换 (truncate floor ceiling round)

整数向浮点数转换是通过 float 函数进行的。而浮点数转换成整数有这样几个
函数：

   truncate 转换成靠近 0 的整数
   floor 转换成最接近的不比本身大的整数
   ceiling 转换成最接近的不比本身小的整数
   round 四舍五入后的整数，换句话说和它的差绝对值最小的整数

很晕是吧。自己用 1.2, 1.7, -1.2, -1.7 对这四个函数操作一遍就知道区别了
（可以直接看 info。按键顺序是 C-h i m elisp RET m Numeric Conversions
RET。以后简写成 info elisp - Numeric Conversions）。

这里提一个问题，浮点数的范围是无穷大的，而整数是有范围的，如果用前面的
函数转换 1e20 成一个整数会出现什么情况呢？试试就知道了。

**** 数的运算 (+ - * /)

四则运算没有什么好说的，就是 + - * /。值得注意的是，和 C 语言类似，如果参数都是整数，
作除法时要记住 (/ 5 6) 是会等于 0 的。如果参数中有浮点数，整数会自动转换成浮点数进行
运算，所以 (/ 5 6.0) 的值才会是 5/6。 

没有 ++ 和 -- 操作了，类似的两个函数是 1+ 和 1-。可以用 setq 赋值来代替 ++ 和 --：

(setq foo 10)                           ; => 10
(setq foo (1+ foo))                     ; => 11
(setq foo (1- foo))                     ; => 10

注：可能有人看过有 incf 和 decf 两个实现 ++ 和 -- 操作。这两个宏是可以用的。这两个宏是 
Common Lisp 里的，emacs 有模拟的 Common Lisp 的库 cl。但是 RMS 认为最好不要使用这个
库。但是你可以在你的 elisp 包中使用这两个宏，只要在文件头写上：

(eval-when-compile
  (require 'cl))

由于 incf 和 decf 是两个宏，所以这样写不会在运行里导入 cl 库。有点离题是，总之一句话，教
主说不好的东西，我们最好不要用它。其它无所谓，只可惜了两个我最常用的函数 remove-if 和 
remove-if-not。不过如果你也用 emms 的话，可以在 emms-compat 里找到这两个函数的替代品。

**** abs 取数的绝对值
**** % mod 取整函数
有两个取整的函数，一个是符号 %，一个是函数 mod。这两个函数有什么差别呢？一是 % 的第个参数
必须是整数，而 mod 的第一个参数可以是整数也可以是浮点数。二是即使对相同的参数，两个函数也不
一定有相同的返回值：

(+ (% DIVIDEND DIVISOR)
   (* (/ DIVIDEND DIVISOR) DIVISOR))

和 DIVIDEND 是相同的。而：

(+ (mod DIVIDEND DIVISOR)
   (* (floor DIVIDEND DIVISOR) DIVISOR))

和 DIVIDEND 是相同的。

**** 三角运算有函数： sin, cos, tan, asin, acos, atan。
**** 开方函数是 sqrt。
**** exp 以 e 为底的指数运算 
expt 可以指定底数的指数运算。log 默认底数是e，但是也可以指定底数。log10 就是 (log x 10)。
logb 是以 2 为底数运算，但是返回的是一个整数。这个函数是用来计算数的位。

random 可以产生随机数。可以用 (random t) 来产生一个新种子。虽然 emacs 每次启动后调用 random 
总是产生相同的随机数，但是运行过程中，你不知道调用了多少次，所以使用时还是不需要再调用一次 (random t)
来产生新的种子。

**** 位运算
这样高级的操作我就不说了，自己看 info elisp - Bitwise Operations on Integers 吧。

**** 函数列表

;; 测试函数
(integerp OBJECT)
(floatp OBJECT)
(numberp OBJECT)
(zerop NUMBER)
(wholenump OBJECT)
;; 比较函数
(> NUM1 NUM2)
(< NUM1 NUM2)
(>= NUM1 NUM2)
(<= NUM1 NUM2)
(= NUM1 NUM2)
(eql OBJ1 OBJ2)
(/= NUM1 NUM2)
;; 转换函数
(float ARG)
(truncate ARG &optional DIVISOR)
(floor ARG &optional DIVISOR)
(ceiling ARG &optional DIVISOR)
(round ARG &optional DIVISOR)
;; 运算
(+ &rest NUMBERS-OR-MARKERS)
(- &optional NUMBER-OR-MARKER &rest MORE-NUMBERS-OR-MARKERS)
(* &rest NUMBERS-OR-MARKERS)
(/ DIVIDEND DIVISOR &rest DIVISORS)
(1+ NUMBER)
(1- NUMBER)
(abs ARG)
(% X Y)
(mod X Y)
(sin ARG)
(cos ARG)
(tan ARG)
(asin ARG)
(acos ARG)
(atan Y &optional X)
(sqrt ARG)
(exp ARG)
(expt ARG1 ARG2)
(log ARG &optional BASE)
(log10 ARG)
(logb ARG)
;; 随机数
(random &optional N)
** 基本数据类型之二──字符和字符串
*** emacs 字符
   在 emacs 里字符串是有序的字符数组。和 c 语言的字符串数组不同，emacs 的
   字符串可以容纳任何字符，包括 \0:

(setq foo "abc\000abc")                 ; => "abc abc"

   关于字符串有很多高级的属性，例如字符串的表示有单字节和多字节类型，字符
   串可以有文本属性（text property）等等。但是对于刚接触字符串，还是先学
   一些基本操作吧。

   首先构成字符串的字符其实就是一个整数。一个字符 'A' 就是一个整数 65。但是目前
   字符串中的字符被限制在 0-524287 之间。字符的读入语法是在字符前加上一个问号，
   比如 ?A 代表字符 'A'。

?A                                      ; => 65
?a                                      ; => 97

   对于标点来说，也可以用同样的语法，但是最好在前面加上转义字符 '\'，因为有些标点
   会有岐义，比如 '?\('。'\' 必须用 '?\\' 表示。控制字符，退格、制表符，换行符，
   垂直制表符，换页符，空格，回车，删除和 escape 表示为 `?\a', `?\b', `?\t', 
   `?\n', `?\v', `?\f', `?\s', `?\r', `?\d', and `?\e'。

   对于没有特殊意义的字符，加上转义字符 \ 是没有副作用的，比如 '?\+' 和 '?+' 是
   完全一样的。所以标点还是都用转义字符来表示吧。

     ?\a => 7                 ; control-g, `C-g'
     ?\b => 8                 ; backspace, <BS>, `C-h'
     ?\t => 9                 ; tab, <TAB>, `C-i'
     ?\n => 10                ; newline, `C-j'
     ?\v => 11                ; vertical tab, `C-k'
     ?\f => 12                ; formfeed character, `C-l'
     ?\r => 13                ; carriage return, <RET>, `C-m'
     ?\e => 27                ; escape character, <ESC>, `C-['
     ?\s => 32                ; space character, <SPC>
     ?\\ => 92                ; backslash character, `\'
     ?\d => 127               ; delete character, <DEL>

控制字符可以有多种表示方式，比如 C-i，这些都是对的：

?\^I  ?\^i  ?\C-I  ?\C-i

它们都对应数字 9。

meta 字符是用 <META> 修饰键（通常就是 Alt 键）输入的字符。之所以称为修
饰键，是因为这样输入的字符就是在其修饰字符的第 27 位由 0 变成 1 而成，
也就是如下操作：

(logior (lsh 1 27) ?A)                  ; => 134217793
?\M-A                                   ; => 134217793

你可以用 '\M-' 代表 meta 键，加上修饰的字符就是新生成的字符。比如：
?\M-A, ?\M-\C-b. 后面这个也可以写成 ?\C-\M-b。

如果你还记得前面说过字符串里的字符不能超过 524287 的话，这就可以看出字
符串是不能放下一个 meta 字符的。所以按键序列在这时只能用 vector 来储存。

其它的修饰键也是类似的。emacs 用 2**25 位来表示 shift 键，2**24 对应
hyper，2**23 对应 super，2**22 对应 alt。

*** 测试函数 (stringp OBJECT) (string-or-null-p OBJECT)

字符串测试使用 stringp，没有 charp，因为字符就是整数。
string-or-null-p 当对象是一个字符或 nil 时返回 t。char-or-string-p 测
试是否是字符串或者字符类型。 emacs 没有测试字符串是否为空的函数。这是我用的这
个测试函数，使用前要测试字符串是否为 nil：

(defun string-emptyp (str)
  (not (string< "" str)))   ;; 字符串比较函数见*构造函数*

*** 构造函数

产生一个字符串可以用 make-string。这样生成的字符串包含的字符都是一样的
。要生成不同的字符串可以用 string 函数。

(make-string 5 ?x)                      ; => "xxxxx"
(string ?a ?b ?c)                       ; => "abc"

在已有的字符串生成新的字符串的方法有 substring, concat。substring 的后
两个参数是起点和终点的位置。如果终点越界或者终点比起点小都会产生一个错
误。这个在使用 substring 时要特别小心。

(substring "0123456789" 3)              ; => "3456789"
(substring "0123456789" 3 5)            ; => "34"
(substring "0123456789" -3 -1)          ; => "78"

concat 函数相对简单，就是把几个字符串连接起来。

*** 字符串比较

char-equal 可以比较两个字符是否相等。与整数比较不同，这个函数还考虑了
大小写。如果 case-fold-search 变量是 t 时，这个函数的字符比较是忽略大
小写的。编程时要小心，因为通常 case-fold-search 都是 t，这样如果要考虑
字符的大小写时就不能用 char-equal 函数了。

字符串比较使用 string=，string-equal 是一个别名。

string< 是按字典序比较两个字符串，string-less 是它的别名。空字符串小于
所有字符串，除了空字符串。前面 string-emptyp 就是用这个特性。当然直接
用 length 检测字符串长度应该也可以，还可以省去检测字符串是否为空。没有
string> 函数。

*** 转换函数

字符转换成字符串可以用 char-to-string 函数，字符串转换成字符可以用
string-to-char。当然只是返回字符串的第一个字符。

数字和字符串之间的转换可以用 number-to-string 和 string-to-number。其
中 string-to-number 可以设置字符串的进制，可以从 2 到 16。
number-to-string 只能转换成 10 进制的数字。如果要输出八进制或者十六进
制，可以用 format 函数：

(string-to-number "256")                ; => 256
(number-to-string 256)                  ; => "256"
(format "%#o" 256)                      ; => "0400"
(format "%#x" 256)                      ; => "0x100"

如果要输出成二进制，好像没有现成的函数了。calculator 库倒是可以，这是
我写的函数：

(defun number-to-bin-string (number)
  (require 'calculator)
  (let ((calculator-output-radix 'bin)
        (calculator-radix-grouping-mode nil))
    (calculator-number-to-string number)))
(number-to-bin-string 256)              ; => "100000000"

其它数据类型现在还没有学到，不过可以先了解一下吧。concat 可以把一个字
符构成的列表或者向量转换成字符串，vconcat 可以把一个字符串转换成一个向
量，append 可以把一个字符串转换成一个列表。

(concat '(?a ?b ?c ?d ?e))              ; => "abcde"
(concat [?a ?b ?c ?d ?e])               ; => "abcde"
(vconcat "abdef")                       ; => [97 98 100 101 102]
(append "abcdef" nil)                   ; => (97 98 99 100 101 102)

大小写转换使用的是 downcase 和 upcase 两个函数。这两个函数的参数既可以
字符串，也可以是字符。capitalize 可以使字符串中单词的第一个字符大写，
其它字符小写。upcase-initials 只使第一个单词的第一个字符大写，其它字符
小写。这两个函数的参数如果是一个字符，那么只让这个字符大写。比如：

(downcase "The cat in the hat")         ; => "the cat in the hat"
(downcase ?X)                           ; => 120
(upcase "The cat in the hat")           ; => "THE CAT IN THE HAT"
(upcase ?x)                             ; => 88
(capitalize "The CAT in tHe hat")       ; => "The Cat In The Hat"
(upcase-initials "The CAT in the hAt")  ; => "The CAT In The HAt"

*** 格式化字符串 (format STRING &rest OBJECTS)

format 类似于 C 语言里的 printf 可以实现对象的字符串化。数字的格式化和
printf 的参数差不多，值得一提的是 "%S" 这个格式化形式，它可以把对象的
输出形式转换成字符串，这在调试时是很有用的。

*** 查找和替换

字符串查找的核心函数是 string-match。这个函数可以从指定的位置对字符串
进行正则表达式匹配，如果匹配成功，则返回匹配的起点，如：

(string-match "34" "01234567890123456789")    ; => 3
(string-match "34" "01234567890123456789" 10) ; => 13

注意 string-match 的参数是一个 regexp。emacs 好象没有内建的查找子串的
函数。如果你想把 string-match 作为一个查找子串的函数，可以先用
regexp-quote 函数先处理一下子串。比如：

(string-match "2*" "232*3=696")                ; => 0
(string-match (regexp-quote "2*") "232*3=696") ; => 2

事实上，string-match 不只是查找字符串，它更重要的功能是捕捉匹配的字符
串。如果你对正则表达式不了解，可能需要先找一本书，先了解一下什么是正则
表达式。string-match 在查找的同时，还会记录下每个要捕捉的字符串的位置
。这个位置可以在匹配后用 match-data、match-beginning 和 match-end 等函
数来获得。先看一下例子：

(progn
  (string-match "3\\(4\\)" "01234567890123456789")
  (match-data))                         ; => (3 5 4 5)

最后返回这个数字是什么意思呢？正则表达式捕捉的字符串按括号的顺序对应一
个序号，整个模式对应序号 0，第一个括号对应序号 1，第二个括号对应序号 2
，以此类推。所以 "3\\(4\\)" 这个正则表达式中有序号 0 和 1，最后
match-data 返回的一系列数字对应的分别是要捕捉字符串的起点和终点位置，
也就是说子串 "34" 起点从位置 3 开始，到位置 5 结束，而捕捉的字符串 "4"
的起点是从 4 开始，到 5 结束。这些位置可以用 match-beginning 和
match-end 函数用对应的序号得到。要注意的是，起点位置是捕捉字符串的第一
个字符的位置，而终点位置不是捕捉的字符串最后一个字符的位置，而是下一个
字符的位置。这个性质对于循环是很方便的。比如要查找上面这个字符串中所有
34 出现的位置：

(let ((start 0))
  (while (string-match "34" "01234567890123456789" start)
    (princ (format "find at %d\n" (match-beginning 0)))
    (setq start (match-end 0))))

查找会了，就要学习替换了。替换使用的函数是 replace-match。这个函数既可
以用于字符串的替换，也可以用于缓冲区的文本替换。对于字符串的替换，
replace-match 只是按给定的序号把字符串中的那一部分用提供的字符串替换了
而已：

(let ((str "01234567890123456789"))
  (string-match "34" str)
  (princ (replace-match "x" nil nil str 0))
  (princ "\n")
  (princ str))

可以看出 replace-match 返回的字符串是替换后的新字符串，原字符串被没有
改变。

如果你想挑战一下，想想怎样把上面这个字符串中所有的 34 都替换掉？如果想
就使用同一个字符串来存储，可能对于固定的字符串，这个还容易一些，如果不
是的话，就要花一些脑筋了，因为替换之后，新的字符串下一个搜索起点的位置
就不能用 (match-end 0) 给出来的位置了，而是要扣除替换的字符串和被替换
的字符串长度的差值。

emacs 对字符串的替换有一个函数 replace-regexp-in-string。这个函数的实
现方法是把每次匹配部分之前的子串收集起来，最后再把所有字符串连接起来。

单字符的替换有 subst-char-in-string 函数。但是 emacs 没有类似 perl函数
或者程序 tr 那样进行字符替换的函数。只能自己建表进行循环操作了。

*** 函数列表

;; 测试函数
(stringp OBJECT)
(string-or-null-p OBJECT)
(char-or-string-p OBJECT)
;; 构建函数
(make-string LENGTH INIT)
(string &rest CHARACTERS)
(substring STRING FROM &optional TO)
(concat &rest SEQUENCES)
;; 比较函数
(char-equal C1 C2)
(string= S1 S2)
(string-equal S1 S2)
(string< S1 S2)
;; 转换函数
(char-to-string CHAR)
(string-to-char STRING)
(number-to-string NUMBER)
(string-to-number STRING &optional BASE)
(downcase OBJ)
(upcase OBJ)
(capitalize OBJ)
(upcase-initials OBJ)
(format STRING &rest OBJECTS)
;; 查找与替换
(string-match REGEXP STRING &optional START)
(replace-match NEWTEXT &optional FIXEDCASE LITERAL STRING SUBEXP)
(replace-regexp-in-string REGEXP REP STRING &optional FIXEDCASE LITERAL SUBEXP START)
(subst-char-in-string FROMCHAR TOCHAR STRING &optional INPLACE)

** 基本数据类型之三 cons cell 和列表

   如果从概念上来说，cons cell 其实非常简单的，就是两个有顺序的元素。第一个叫 CAR，
第二个就 CDR。CAR 和 CDR 名字来自于 Lisp。它最初在IBM 704机器上的实现。在这种机
器有一种取址模式，使人可以访问一个存储地址中的“地址（address）”部分和“减量（decrement）”
部分。CAR 指令用于取出地址部分，表示(Contents of Address part of Register)，
CDR 指令用于取出地址的减量部分(Contents of the Decrement part of Register)。
cons cell 也就是construction of cells。car 函数用于取得 cons cell 的 CAR 
部分，cdr 取得 cons cell 的 CDR 部分。cons cell 如此简单，但是它却能衍生出许多高级
的数据结构，比如链表，树，关联表等等。

*** cons cell 的读入语法。
cons cell 的读入语法是用，分开两个部分，比如：

'(1 . 2)                                ; => (1 . 2)
'(?a . 1)                               ; => (97 . 1)
'(1 . "a")                              ; => (1 . "a")
'(1 . nil)                              ; => (1)
'(nil . nil)                            ; => (nil)

注意到前面的表达式中都有一个 ' 号，这是什么意思呢？其实理解了eval-last-sexp 的作用就
能明白了。eval-last-sexp 其实包含了两个步骤，一是读入前一个 S-表达式，二是对读入的 
S-表达式求值。这样如果读入的 S-表达式是一个 cons cell 的话，求值时会把这个 cons cell 
的第一个元素作为一个函数来调用。而事实上，前面这些例子的第一个元素都不是一个函数，这样就
会产生一个错误 invalid-function。之所以前面没有遇到这个问题，那是因为前面数字和字符串
是一类特殊的 S-表达式，它们求值后和求值前是不变，称为自求值表达式（self-evaluating form）。
   ' 号其实是一个特殊的函数 quote，它的作用是将它的参数返回而不作求值。'(1 . 2) 等价
于 (quote (1 . 2))。为了证明 cons cell 的读入语法确实就是它的输出形式，可以看下面这
个语句：

(read "(1 . 2)")                        ; => (1 . 2)


列表包括了 cons cell。但是列表中有一个特殊的元素──空表 nil。

nil                                     ; => nil
'()                                     ; => nil

空表不是一个 cons cell，因为它没有 CAR 和 CDR 两个部分，事实上空表里没
有任何内容。但是为了编程的方便，可以认为 nil 的 CAR 和 CDR 都是 nil：

(car nil)                               ; => nil
(cdr nil)                               ; => nil

按列表最后一个 cons cell 的 CDR 部分的类型分，可以把列表分为三类。如果
它是 nil 的话，这个列表也称为“真列表”(true list)。如果既不是 nil 也不
是一个 cons cell，则这个列表称为“点列表”(dotted list)。还有一种可能，
它指向列表中之前的一个 cons cell，则称为环形列表(circular list)。这里
分别给出一个例子：

'(1 2 3)                                  ; => (1 2 3)
'(1 2 . 3)                                ; => (1 2 . 3)
'(1 . #1=(2 3 . #1#))                     ; => (1 2 3 . #1)

从这个例子可以看出前两种列表的读入语法和输出形式都是相同的，而环形列表
的读入语法是很古怪的，输出形式不能作为环形列表的读入形式。

如果把真列表最后一个 cons cell 的 nil 省略不写，也就是 (1 . nil) 简写成 (1)，
把 '( obj1 . ( obj2 . list)) 简写成 (obj1 obj2 . list)，那么列

表最后可以写成一个用括号括起的元素列表：

(car (2 . 3))

'(1 . (2 . (3 . nil)))                  ; => (1 2 3)

尽管这样写是清爽多了，但是，我觉得看一个列表时还是在脑子里反映的前面的
形式，这样在和复杂的 cons cell 打交道时就不会搞不清楚这个 cons cell 的
CDR 是一个列表呢，还是一个元素或者是嵌套的列表。

*** 测试函数

测试一个对象是否是 cons cell 用 consp，是否是列表用 listp。

(consp '(1 . 2))                        ; => t
(consp '(1 . (2 . nil)))                ; => t
(consp nil)                             ; => nil
(listp '(1 . 2))                        ; => t
(listp '(1 . (2 . nil)))                ; => t
(listp nil)                             ; => t

没有内建的方法测试一个列表是不是一个真列表。通常如果一个函数需要一个真
列表作为参数，都是在运行时发出错误，而不是进行参数检查，因为检查一个列
表是真列表的代价比较高。

测试一个对象是否是 nil 用 null 函数。只有当对象是空表时，null 才返回空
值。

*** 构造函数 cons cell 

生成一个 cons cell 可以用 cons 函数。比如：

(cons 1 2)                              ; => (1 . 2)
(cons 1 '())                            ; => (1)

这也是在列表前面增加元素的方法。比如：

(setq foo '(a b))                       ; => (a b)
(cons 'x foo)                           ; => (x a b)

值得注意的是前面这个例子的 foo 值并没有改变。事实上有一个宏 push 可以
加入元素的同时改变列表的值：

(push 'x foo)                           ; => (x a b)
foo                                     ; => (x a b)

生成一个列表的函数是 list。比如：

(list 1 2 3)                            ; => (1 2 3)
(defun test-fun()
(list seen ancestor tree-list)
)

可能这时你有一个疑惑，前面产生一个列表，我常用 quote（也就是 ' 符号）
这个函数，它和这个 cons 和 list 函数有什么区别呢？其实区别是很明显的，
quote 是把参数直接返回不进行求值，而 list 和 cons 是对参数求值后再生成
一个列表或者 cons cell。看下面这个例子：

'((+ 1 2) 3)                            ; => ((+ 1 2) 3)
(list (+ 1 2) 3)                        ; => (3 3)

前一个生成的列表的 CAR 部分是 (+ 1 2) 这个列表，而后一个是先对 (+ 1 2)
求值得到 3 后再生成列表。如果你觉得你有点明白的话，我提一个问题考考你
：怎样用 list 函数构造一个 (a b c) 这样的列表呢？

前面提到在列表前端增加元素的方法是用 cons，在列表后端增加元素的函数是
用 append。比如：

(append '(a b) '(c))                    ; => (a b c)

append 的功能可以认为它是把第一个参数最后一个列表的 nil 换成第二个参数
，比如前面这个例子，第一个参数写成 cons cell 表示方式是(a . (b . nil))
，把这个 nil 替换成 (c) 就成了 (a . (b . (c)))。对于多个参数的情况也是
一样的，依次把下一个参数替换新列表最后一个 nil 就是最后的结果了。

(append '(a b) '(c) '(d))               ; => (a b c d)

一般来说 append 的参数都要是列表，但是最后一个参数可以不是一个列表，这
也不违背前面说的，因为 cons cell 的 CDR 部分本来就可以是任何对象：

(append '(a b) 'c)                      ; => (a b . c)

这样得到的结果就不再是一个列表了，如果再进行 append 操作就会产生一个错
误。

如果你写过 c 的链表类型，可能就知道如果链表只保留一个指针，那么链表只
能在一端增加元素。elisp 的列表类型也是类似的，用 cons 在列表前增加元素
比用 append 要快得多。

append 的参数不限于列表，还可以是字符串或者向量。前面字符串里已经提到
可以把一个字符串转换成一个字符列表，同样可能把向量转换成一个列表：

(append [a b] "cd" nil)                 ; => (a b 99 100)

注意前面最后一个参数 nil 是必要的，不然你可以想象得到的结果是什么。

*** 把列表当数组用

要得到列表或者 cons cell 里元素，唯一的方法是用 car 和 cdr 函数。很容
易明白，car 就是取得 cons cell 的 CAR 部分，cdr 函数就是取得 cons cell
的 CDR 部分。通过这两个函数，我们就能访问 cons cell 和列表中的任何元素
。你如果知道 elisp 的函数如果定义，并知道 if 的使用方法，不妨自己写一
个函数来取得一个列表的第 n 个 CDR。

通过使用 elisp 提供的函数，我们事实上是可以把列表当数组来用。依惯例，
我们用 car 来访问列表的第一个元素，cadr 来访问第二个元素，再往后就没有
这样的函数了，可以用 nth 函数来访问：

(nth 3 '(0 1 2 3 4 5))                  ; => 3

获得列表一个区间的函数有 nthcdr、last 和 butlast。nthcdr 和 last 比较
类似，它们都是返回列表后端的列表。nthcdr 函数返回第 n 个元素后的列表：

(nthcdr 2 '(0 1 2 3 4 5))               ; => (2 3 4 5)

last 函数返回倒数 n 个长度的列表：

(last '(0 1 2 3 4 5) 2)                 ; => (4 5)

butlast 和前两个函数不同，返回的除了倒数 n 个元素的列表。

(butlast '(0 1 2 3 4 5) 2)              ; => (0 1 2 3)

这里出一个思考题，如何得到某个区间（比如从3到5之间）的列表（提示列表长
度可以用 length 函数得到）：

(my-subseq '(0 1 2 3 4 5) 2 5)          ; => (2 3 4)

使用前面这几个函数访问列表是没有问题了。但是你也可以想象，链表这种数据
结构是不适合随机访问的，代价比较高，如果你的代码中频繁使用这样的函数或
者对一个很长的列表使用这样的函数，就应该考虑是不是应该用数组来实现。

直到现在为止，我们用到的函数都不会修改一个已有的变量。这是函数式编程的
一个特点。只用这些函数编写的代码是很容易调试的，因为你不用去考虑一个变
量在执行一个代码后就改变了，不用考虑变量的引用情况等等。下面就要结束这
样轻松的学习了。

首先学习怎样修改一个 cons cell 的内容。首先 setcar 和 setcdr 可以修改
一个 cons cell 的 CAR 部分和 CDR 部分。比如：

(setq foo '(a b c))                     ; => (a b c)
(setcar foo 'x)                         ; => x
foo                                     ; => (x b c)
(setcdr foo '(y z))                     ; => (y z)
foo                                     ; => (x y z)

好像很简单是吧。我出一个比较 bt 的一个问题：

(setq foo '(a b c))                     ; => (a b c)
(setcdr foo foo)

现在 foo 是什么东西呢？答案自己找吧。

现在来考虑一下，怎样像数组那样直接修改列表。使用 setcar 和 nthcdr 的组
合就可以实现了：

(setq foo '(1 2 3))                     ; => (1 2 3)
(setcar foo 'a)                         ; => a
(setcar (cdr foo) 'b)                   ; => b
(setcar (nthcdr 2 foo) 'c)              ; => c
foo                                     ; => (a b c)

*** 把列表当堆栈用

前面已经提到过可以用 push 向列表头端增加元素，在结合 pop 函数，列表就
可以做为一个堆栈了。

(setq foo nil)                          ; => nil
(push 'a foo)                           ; => (a)
(push 'b foo)                           ; => (b a)
(pop foo)                               ; => b
foo                                     ; => (a)

*** 重排列表

如果一直用 push 往列表里添加元素有一个问题是这样得到的列表和加入的顺序
是相反的。通常我们需要得到一个反向的列表。reverse 函数可以做到这一点：

(setq foo '(a b c))                     ; => (a b c)
(reverse foo)                           ; => (c b a)

需要注意的是使用 reverse 后 foo 值并没有改变。不要怪我太啰唆，如果你看
到一个函数 nreverse，而且确实它能返回逆序的列表，不明所以就到处乱用，
迟早会写出一个错误的函数。这个 nreverse 和前面的 reverse 差别就在于它
是一个有破坏性的函数，也就是说它会修改它的参数。

(nreverse foo)                          ; => (c b a)
foo                                     ; => (a)

为什么现在 foo 指向的是列表的末端呢？如果你实现过链表就知道，逆序操作
是可以在原链表上进行的，这样原来头部指针会变成链表的尾端。列表也是（应
该是，我也没有看过实现）这个原理。使用 nreverse 的唯一的好处是速度快，
省资源。所以如果你只是想得到逆序后的列表就放心用 nreverse，否则还是用
reverse 的好。

elisp 还有一些是具有破坏性的函数。最常用的就是 sort 函数：

(setq foo '(3 2 4 1 5))                 ; => (3 2 4 1 5)
(sort foo '<)                           ; => (1 2 3 4 5)
foo                                     ; => (3 4 5)

这一点请一定要记住，我就曾经在 sort 函数上犯了好几次错误。那如果我既要
保留原列表，又要进行 sort 操作怎么办呢？可以用 copy-sequence 函数。这
个函数只对列表进行复制，返回的列表的元素还是原列表里的元素，不会拷贝列
表的元素。

nconc 和 append 功能相似，但是它会修改除最后一个参数以外的所有的参数，
nbutlast 和 butlast 功能相似，也会修改参数。这些函数都是在效率优先时才
使用。总而言之，以 n 开头的函数都要慎用。

*** 把列表当集合用

列表可以作为无序的集合。合并集合用 append 函数。去除重复的 equal 元素
用 delete-dups。查找一个元素是否在列表中，如果测试函数是用 eq，就用
memq，如果测试用 equal，可以用 member。删除列表中的指定的元素，测试函
数为 eq 对应 delq 函数，equal 对应 delete。还有两个函数 remq 和 remove
也是删除指定元素。它们的差别是 delq 和 delete 可能会修改参数，而 remq
和 remove 总是返回删除后列表的拷贝。注意前面这是说的是可能会修改参数的
值，也就是说可能不会，所以保险起见，用 delq 和 delete 函数要么只用返回
值，要么用 setq 设置参数的值为返回值。

(setq foo '(a b c))                     ; => (a b c)
(remq 'b foo)                           ; => (a c)
foo                                     ; => (a b c)
(delq 'b foo)                           ; => (a c)
foo                                     ; => (a c)
(delq 'a foo)                           ; => (c)
foo                                     ; => (a c)

*** 把列表当关联表

用在 elisp 编程中，列表最常用的形式应该是作为一个关联表了。所谓关联表
，就是可以用一个字符串（通常叫关键字，key）来查找对应值的数据结构。由
列表实现的关联表有一个专门的名字叫 association list。尽管 elisp里也有
hash table，但是 hash table 相比于 association list 至少这样几个缺点：

   hash table 里的关键字（key）是无序的，而 association list 的关键字
    可以按想要的顺序排列
   hash table 没有列表那样丰富的函数，只有一个 maphash 函数可以遍历列
    表。而 association list 就是一个列表，所有列表函数都能适用
   hash table 没有读入语法和输入形式，这对于调试和使用都带来很多不便

所以 elisp的hash table 不是一个首要的数据结构，只要不对效率要求很高，
通常直接用association list。数组可以作为关联表，但是数组不适合作为与人
交互使用数据结构（毕竟一个有意义的名字比纯数字的下标更适合人脑）。所以
关联表的地位在 elisp 中就非比寻常了，emacs 为关联表专门用 c 程序实现了
查找的相关函数以提高程序的效率。在 association list 中关键字是放在元素
的 CAR 部分，与它对应的数据放在这个元素的 CDR 部分。根据比较方法的不同
，有 assq 和assoc 两个函数，它们分别对应查找使用 eq 和 equal 两种方法
。例如：

(assoc "a" '(("a" 97) ("b" 98)))        ; => ("a" 97)
(assq 'a '((a . 97) (b . 98)))          ; => (a . 97)

通常我们只需要查找对应的数据，所以一般来说都要用 cdr 来得到对应的数据：


(cdr (assoc "a" '(("a" 97) ("b" 98))))  ; => (97)
(cdr (assq 'a '((a . 97) (b . 98))))    ; => 97

assoc-default 可以一步完成这样的操作：

(assoc-default "a" '(("a" 97) ("b" 98)))          ; => (97)

如果查找用的键值（key）对应的数据也可以作为一个键值的话，还可以用
rassoc 和 rassq 来根据数据查找键值：

(rassoc '(97) '(("a" 97) ("b" 98)))     ; => ("a" 97)
(rassq '97 '((a . 97) (b . 98)))        ; => (a . 97)

如果要修改关键字对应的值，最省事的作法就是用 cons 把新的键值对加到列表
的头端。但是这会让列表越来越长，浪费空间。如果要替换已经存在的值，一个
想法就是用 setcdr 来更改键值对应的数据。但是在更改之前要先确定这个键值
在对应的列表里，否则会产生一个错误。另一个想法是用 assoc 查找到对应的
元素，再用 delq 删除这个数据，然后用 cons 加到列表里：

(setq foo '(("a" . 97) ("b" . 98)))     ; => (("a" . 97) ("b" . 98))

;; update value by setcdr
(if (setq bar (assoc "a" foo))
    (setcdr bar "this is a")
  (setq foo (cons '("a" . "this is a") foo))) ; => "this is a"
foo                         ; => (("a" . "this is a") ("b" . 98))
;; update value by delq and cons
(setq foo (cons '("a" . 97)
                (delq (assoc "a" foo) foo))) ; => (("a" . 97) ("b" . 98))

如果不对顺序有要求的话，推荐用后一种方法吧。这样代码简洁，而且让最近更
新的元素放到列表前端，查找更快。

*** 把列表当树用

列表的第一个元素如果作为结点的数据，其它元素看作是子节点，就是一个树了。由于树的操作
都涉及递归，现在还没有说到函数，我就不介绍了。（其实是我不太熟，就不班门弄斧了）。

*** 遍历列表

遍历列表最常用的函数就是 mapc 和 mapcar 了。它们的第一个参数都是一个函
数，这个函数只接受一个参数，每次处理一个列表里的元素。这两个函数唯一的
差别是前者返回的还是输入的列表，而 mapcar 返回的函数返回值构成的列表：

(mapc '1+ '(1 2 3))                     ; => (1 2 3)
(mapcar '1+ '(1 2 3))                   ; => (2 3 4)

另一个比较常用的遍历列表的方法是用 dolist。它的形式是：

(dolist (var list [result]) body...)

其中 var 是一个临时变量，在 body 里可以用来得到列表中元素的值。使用
dolist 的好处是不用写lambda 函数。一般情况下它的返回值是 nil，但是你也
可以指定一个值作为返回值（我觉得这个特性没有什么用，只省了一步而已）：

(dolist (foo '(1 2 3))
  (incf foo))                           ; => nil
(setq bar nil)
(dolist (foo '(1 2 3) bar)
  (push (incf foo) bar))                ; => (4 3 2)

*** 其它常用函数

如果看过一些函数式语言教程的话，一定对 fold（或叫 accumulate、reduce）
和 filter 这些函数记忆深刻。不过 elisp 里好像没有提供这样的函数。
remove-if 和 remove-if-not 可以作 filter 函数，但是它们是 cl 里的，自
己用用没有关系，不能强迫别人也跟着用，所以不能写到 elisp 里。如果不用
这两个函数，也不用别人的函数的话，自己实现不妨用这样的方法：

(defun my-remove-if (predicate list)
  (delq nil (mapcar (lambda (n)
                      (and (not (funcall predicate n)) n))
                    list)))
(defun evenp (n)
  (= (% n 2) 0))
(my-remove-if 'evenp '(0 1 2 3 4 5))    ; => (1 3 5)

fold 的操作只能用变量加循环或 mapc 操作来代替了：

(defun my-fold-left (op initial list)
  (dolist (var list initial)
    (setq initial (funcall op initial var))))
(my-fold-left '+ 0 '(1 2 3 4))          ; => 10

这里只是举个例子，事实上你不必写这样的函数，直接用函数里的遍历操作更好一些。

产生数列常用的方法是用 number-sequence（这里不禁用说一次，不要再用loop 
产生 tab-stop-list 了，你们 too old 了）。不过这个函数好像在emacs21 
时好像还没有。

解析文本时一个很常用的操作是把字符串按分隔符分解，可以用 split-string
函数：

(split-string "key = val" "\\s-*=\\s-*")  ; => ("key" "val")

与 split-string 对应是把几个字符串用一个分隔符连接起来，这可以用mapconcat 
完成。比如：

(mapconcat 'identity '("a" "b" "c") "\t") ; => "a   b   c"

identity 是一个特殊的函数，它会直接返回参数。mapconcat 第一个参数是一
个函数，可以很灵活的使用。

*** 函数列表

;; 列表测试
(consp OBJECT)
(listp OBJECT)
(null OBJECT)
;; 列表构造
(cons CAR CDR)
(list &rest OBJECTS)
(append &rest SEQUENCES)
;; 访问列表元素
(car LIST)
(cdr LIST)
(cadr X)
(caar X)
(cddr X)
(cdar X)
(nth N LIST)
(nthcdr N LIST)
(last LIST &optional N)
(butlast LIST &optional N)
;; 修改 cons cell
(setcar CELL NEWCAR)
(setcdr CELL NEWCDR)
;; 列表操作
(push NEWELT LISTNAME)
(pop LISTNAME)
(reverse LIST)
(nreverse LIST)
(sort LIST PREDICATE)
(copy-sequence ARG)
(nconc &rest LISTS)
(nbutlast LIST &optional N)
;; 集合函数
(delete-dups LIST)
(memq ELT LIST)
(member ELT LIST)
(delq ELT LIST)
(delete ELT SEQ)
(remq ELT LIST)
(remove ELT SEQ)
;; 关联列表
(assoc KEY LIST)
(assq KEY LIST)
(assoc-default KEY ALIST &optional TEST DEFAULT)
(rassoc KEY LIST)
(rassq KEY LIST)
;; 遍历函数
(mapc FUNCTION SEQUENCE)
(mapcar FUNCTION SEQUENCE)
(dolist (VAR LIST [RESULT]) BODY...)
;; 其它
(number-sequence FROM &optional TO INC)
(split-string STRING &optional SEPARATORS OMIT-NULLS)
(mapconcat FUNCTION SEQUENCE SEPARATOR)
(identity ARG)

*** 问题解答

用 list 生成 (a b c)

答案是 (list 'a 'b 'c)。很简单的一个问题。从这个例子可以看出为什么要想
出用 ' 来输入列表。这就是程序员“懒”的美德呀！

nthcdr 的一个实现

(defun my-nthcdr (n list)
  (if (or (null list) (= n 0))
      (car list)
    (my-nthcdr (1- n) (cdr list))))

这样的实现看上去很简洁，但是一个最大的问题的 elisp 的递归是有限的，所
以如果想这个函数没有问题，还是用循环还实现比较好。

my-subseq 函数的定义

(defun my-subseq (list from &optional to)
  (if (null to) (nthcdr from list)
    (butlast (nthcdr from list) (- (length list) to))))

(setcdr foo foo) 是什么怪东西？

可能你已经想到了，这就是传说中的环呀。这在 info elisp - Circular
Objects 里有介绍。elisp 里用到这样的环状列表并不多见，但是也不是没有，
org 和 session 那个 bug 就是由于一个环状列表造成的。

** 基本数据类型之四 序列和数组

序列是列表和数组的统称，也就是说列表和数组都是序列。它们的共性是内部的元素都是有序的。
elisp 里的数组包括字符串、向量、char-table 和布尔向量。它们的关系可以用下面图表示：

               _____________________________________________
              |                                             |
              |          Sequence                           |
              |  ______   ________________________________  |
              | |      | |                                | |
              | | List | |             Array              | |
              | |      | |    ________       ________     | |
              | |______| |   |        |     |        |    | |
              |          |   | Vector |     | String |    | |
              |          |   |________|     |________|    | |
              |          |  ____________   _____________  | |
              |          | |            | |             | | |
              |          | | Char-table | | Bool-vector | | |
              |          | |____________| |_____________| | |
              |          |________________________________| |
              |_____________________________________________|

*** 数组的特性
数组有这样一些特性：

   1 数组内的元素都对应一个下标，第一个元素下标为 0，接下来是 1。数组内的元素可以在常数时间内访问。
   2 数组在创建之后就无法改变它的长度。
   3 数组是自求值的。
   4 数组里的元素都可以用 aref 来访问，用 aset 来设置。

向量可以看成是一种通用的数组，它的元素可以是任意的对象。而字符串是一种
特殊的数组，它的元素只能是字符。如果元素是字符时，使用字符串相比向量更
好，因为字符串需要的空间更少（只需要向量的1/4），输出更直观，能用文本
属性（text property），能使用 emacs 的 IO 操作。但是有时必须使用向量，
比如存储按键序列。

由于 char-table 和 bool-vector 使用较少，而且较难理解，这里就不介绍了。

*** 测试函数

sequencep 用来测试一个对象是否是一个序列。arrayp 测试对象是否是数组。
vectorp、char-table-p 和 bool-vector-p 分别测试对象是否是向量、
char-table、bool-vector。

*** 序列的通用函数

一直没有提到一个重要的函数 length，它可以得到序列的长度。但是这个函数
只对真列表有效。对于一个点列表和环形列表这个函数就不适用了。点列表会出
参数类型不对的错误，而环形列表就更危险，会陷入死循环。如果不确定参数类
型，不妨用 safe-length。比如：

(safe-length '(a . b))                  ; => 1
(safe-length '#1=(1 2 . #1#))           ; => 3

*** 思考题
    写一个函数来检测列表是否是一个环形列表。由于现在还没有介绍 let 绑
定和循环，不过如果会函数定义，还是可以用递归来实现的。

取得序列里第 n 个元素可以用 elt 函数。但是我建议，对于已知类型的序列，
还是用对应的函数比较好。也就是说，如果是列表就用 nth，如果是数组就用
aref。这样一方面是省去 elt 内部的判断，另一方面读代码时能很清楚知道序
列的类型。

copy-sequence 在前面已经提到了。不过同样 copy-sequence 不能用于点列表
和环形列表。对于点列表可以用 copy-tree 函数。环形列表就没有办法复制了
。好在这样的数据结构很少用到。

*** 数组操作

**** 创建向量可以用 vector 函数：

(vector 'foo 23 [bar baz] "rats")

当然也可以直接用向量的读入语法创建向量，但是由于数组是自求值的，所以这
样得到的向量和原来是一样的，也就是说参数不进行求值，看下面的例子就明白
了：

foo                                     ; => (a b)
[foo]                                   ; => [foo]
(vector foo)                            ; => [(a b)]

**** 用 make-vector 可以生成元素相同的向量。

(make-vector 9 'Z)                      ; => [Z Z Z Z Z Z Z Z Z]

fillarray 可以把整个数组用某个元素填充。

(fillarray (make-vector 3 'Z) 5)        ; => [5 5 5]

**** aref 和 aset 可以用于访问和修改数组的元素。
     如果使用下标超出数组长度的话，会产生一个错误。所以要先确定数组的
长度才能用这两个函数。

vconcat 可以把多个序列用 vconcat 连接成一个向量。但是这个序列必须是真
列表。这也是把列表转换成向量的方法。

(vconcat [A B C] "aa" '(foo (6 7)))     ; => [A B C 97 97 foo (6 7)]

(let ((n 0)
      (v (make-vector 100 "nn")))
(while (< n (length v))
(message "%s" (elt v n))
(setq n (1+ n))
))


(message n)
(setq n (+ n 1)
)

把向量转换成列表可以用 append 函数，这在前一节中已经提到。

**** 函数列表

;; 测试函数
(sequencep OBJECT)
(arrayp OBJECT)
(vectorp OBJECT)
(char-table-p OBJECT)
(bool-vector-p OBJECT)
;; 序列函数
(length SEQUENCE)
(safe-length LIST)
(elt SEQUENCE N)
(copy-sequence ARG)
(copy-tree TREE &optional VECP)
;; 数组函数
(vector &rest OBJECTS)
(make-vector LENGTH INIT)
(aref ARRAY IDX)
(aset ARRAY IDX NEWELT)
(vconcat &rest SEQUENCES)
(append &rest SEQUENCES)

**** 问题解答

测试列表是否是环形列表

这个算法是从 safe-length 定义中得到的。你可以直接看它的源码。下面是我
写的函数。

(defun circular-list-p (list)
  (circular-list-p-1 (cdr list) list 0))

(defun circular-list-p-1 (tail halftail len)
  (if (eq tail halftail)
      t
    (if (consp tail)
        (circular-list-p-1 (cdr tail)
                           (if (= (% len 2) 0)
                               (cdr halftail)
                             halftail)
                           (1+ len))
      nil)))

** 基本数据类型之五 符号

符号是有名字的对象。可能这么说有点抽象。作个不恰当的比方，符号可以看作
是 C 语言里的指针。通过符号你可以得到和这个符号相关联的信息，比如值，
函数，属性列表等等。

首先必须知道的是符号的命名规则。符号名字可以含有任何字符。大多数的符号
名字只含有字母、数字和标点“-+=*/”。这样的名字不需要其它标点。名字前缀
要足够把符号名和数字区分开来，如果需要的话，可以在前面用 \ 表示为符号
，比如：

(symbolp '+1)                           ; => nil
(symbolp '\+1)                          ; => t
(symbol-name '\+1)                      ; => "+1"

其它字符 _~!@$%^&:<>{}? 用的比较少。但是也可以直接作为符号的名字。任何
其它字符都可以用 \ 转义后用在符号名字里。但是和字符串里字符表示不同，\
转义后只是表示其后的字符，比如 \t 代表的字符 t，而不是制表符。如果要在
符号名里使用制表符，必须在 \ 后加上制表符本身。

符号名是区分大小写的。这里有一些符号名的例子：

     foo                 ; 名为 `foo' 的符号
     FOO                 ; 名为 `FOO' 的符号，和 `foo' 不同
     char-to-string      ; 名为 `char-to-string' 的符号
     1+                  ; 名为 `1+' 的符号 (不是整数 `+1')
     \+1                 ; 名为 `+1' 的符号 (可读性很差的名字)
     \(*\ 1\ 2\)         ; 名为 `(* 1 2)' 的符号 (更差劲的名字).
     + -*/_~!@$%^&=:<>{}  ; 名为 `+-*/_~!@$%^&=:<>{}' 的符号.
                         ;   这些字符无须转义

*** 创建符号
**** obarray 是什么? 符号名和 obarray 的关系.

一个名字如何与数据对应上呢？这就要了解一下符号是如何创建的了。符号名要有唯一性，
所以一定会有一个表与名字关联，这个表在 elisp 里称为 obarray。从这个名字可以
看出这个表是用数组类型，事实上是一个向量。当 emacs 创建一个符号时，首先会对这
个名字求 hash 值以得到一个在 obarray 这个向量中查找值所用的下标。hash 是查
找字符串的很有效的方法。这里强调的是 obarray 不是一个特殊的数据结构，就是一个
一般的向量。全局变量 obarray里 emacs 所有变量、函数和其它符号所使用的 obarray
（注意不同语境中obarray的含义不同。前一个 obarray 是变量名，后一个 obarray 
是数据类型名）。也可以自己建立向量，把这个向量作为 obarray 来使用。这是一种代
替散列的一种方法。它比直接使用散列有这样一些好处：

   符号不仅可以有一个值，还可以用属性列表，后者又可以相当于一个关联列
    表。这样有很高的扩展性，而且可以表达更高级的数据结构。
   emacs 里有一些函数可以接受 obarray 作为参数，比如补全相关的函数。

当 lisp 读入一个符号时，通常会先查找这个符号是否在 obarray 里出现过，
如果没有则会把这个符号加入到 obarray 里。这样查找并加入一个符号的过程
称为是 intern。intern 函数可以查找或加入一个名字到 obarray 里，返回对
应的符号。默认是全局的obarray，也可以指定一个 obarray。intern-soft 与
intern 不同的是，当名字不在 obarray 里时，intern-soft 会返回 nil，而
intern 会加入到 obarray里。为了不污染 obarray，我下面的例子中尽量在
foo 这个 obarray 里进行。一般来说，去了 foo 参数，则会在 obarray 里进
行。其结果应该是相同的：

(setq foo (make-vector 10 0))           ; => [0 0 0 0 0 0 0 0 0 0]
(intern-soft "abc" foo)                 ; => nil
(intern "abc" foo)                      ; => abc
(intern-soft "abc" foo)                 ; => abc

lisp 每读入一个符号都会 intern 到 obarray 里，如果想避免，可以用在符号
名前加上#:：

(intern-soft "abc")                     ; => nil
'abc                                    ; => abc
(intern-soft "abc")                     ; => abc
(intern-soft "abcd")                    ; => nil
'#:abcd                                 ; => abcd
(intern-soft "abcd")                    ; => nil

*** 删除 obarray 里的符号
如果想除去 obarray 里的符号，可以用 unintern 函数。unintern 可以用符号
名或符号作参数在指定的 obarray 里去除符号，成功去除则返回 t，如果没有
查找到对应的符号则返回 nil：

(intern-soft "abc" foo)                 ; => abc
(unintern "abc" foo)                    ; => t
(intern-soft "abc" foo)                 ; => nil

*** 遍历obarray
和 hash-table 一样，obarray 也提供一个 mapatoms 函数来遍历整个 obarray
。比如要计算 obarray 里所有的符号数量：

(setq count 0)                          ; => 0
(defun count-syms (s)
  (setq count (1+ count)))              ; => count-syms

;; 遍历并且打印
(defun print-syms (s)
(message "symbol %s" s)
)

(mapatoms 'print-syms)

(mapatoms 'count-syms)                  ; => nil
count                                   ; => 28371
(length obarray)                        ; => 1511

*** 思考题
    由前面的例子可以看出elisp 中的向量长度都是有限的，而 obarray 里的
    符号有成千上万个。那这些符号是怎样放到 obarray 里的呢？

*** 符号的组成

每个符号可以对应四个组成部分，一是符号的名字，可以用 symbol-name 访问。
二是符号的值。符号的值可以通过 set 函数来设置，用 symbol-value 来访
问。

(set (intern "abc" foo) "I'm abc")      ; => "I'm abc"
(symbol-value (intern "abc" foo))       ; => "I'm abc"

可能大家最常见到 setq 函数，而 set 函数确很少见到。setq 可以看成是一个
宏，它可以让你用 (setq sym val) 代替 (set (quote sym) val)。事实上这也
是它名字的来源 (q 代表 quoted)。但是 setq 只能设置 obarray 里的变量，
前面这个例子中就只能用 set 函数。

符号的第三个组成部分是函数。它可以用 symbol-function 来访问，用 fset
来设置：

(fset (intern "abc" foo) (symbol-function 'car)) ; => #<subr car>
(funcall (intern "abc" foo) '(a . b))            ; => a

(fset (intern "abc" foo))

符号的第四个组成部分是属性列表(property list)。通常属性列表用于存储和
符号相关的信息，比如变量和函数的文档，定义的文件名和位置，语法类型。属
性名和值可以是任意的 lisp 对象，但是通常名字是符号，可以用 get 和 put
来访问和修改属性值，用 symbol-plist 得到所有的属性列表：

(put (intern "abc" foo) 'doc "this is abc")      ; => "this is abc"
(get (intern "abc" foo) 'doc)                    ; => "this is abc"
(symbol-plist (intern "abc" foo))                ; => (doc "this is abc")
(symbol-plist (intern "usdx-1hr" tplan-vars)     ; => (doc "this is abc")

关联列表和属性列表很相似。符号的属性列表在内部表示上是用(prop1 value1
prop2 value2 ...) 的形式，和关联列表也是很相似的。属性列表在查找和这个
符号相关的信息时，要比直接用关联列表要简单快捷的多。所以变量的文档等信
息都是放在符号的属性列表里。但是关联表在头端加入元素是很快的，而且它可
以删除表里的元素。而属性列表则不能删除一个属性。

如果已经把属性列表取出，那么还可以用 plist-get 和 plist-put 的方法来访
问和设置属性列表：

(plist-get '(foo 4) 'foo)               ; => 4
(plist-get '(foo 4 bad) 'bar)           ; => nil
(setq my-plist '(bar t foo 4))          ; => (bar t foo 4)
(setq my-plist (plist-put my-plist 'foo 69)) ; => (bar t foo 69)
(setq my-plist (plist-put my-plist 'quux '(a))) ; => (bar t foo 69 quux (a))

*** 思考题
    你能不能用已经学过的函数来实现 plist-get 和 plist-put？

*** 函数列表

(symbolp OBJECT)
(intern-soft NAME &optional OBARRAY)
(intern STRING &optional OBARRAY)
(unintern NAME &optional OBARRAY)
(mapatoms FUNCTION &optional OBARRAY)
(symbol-name SYMBOL)
(symbol-value SYMBOL)
(set SYMBOL NEWVAL)
(setq SYM VAL SYM VAL ...)
(symbol-function SYMBOL)
(fset SYMBOL DEFINITION)
(symbol-plist SYMBOL)
(get SYMBOL PROPNAME)
(put SYMBOL PROPNAME VALUE)

*** 问题解答

obarray 里符号数为什么大于向量长度

其实这和散列的的实现是一样的。obarray 里的每一个元素通常称为 bucket。
一个 bucket 是可以容纳多个相同 hash 值的字符串和它们的数据。我们可以用
这样的方法来模拟一下：

(defun hash-string (str)
  (let ((hash 0) c)
    (dotimes (i (length str))
      (setq c (aref str i))
      (if (> c #o140)
          (setq c (- c 40)))
      (setq hash (+ (setq hash (lsh hash 3))
                    (lsh hash -28)
                    c)))
    hash))

(let ((len 10) str hash)
  (setq foo (make-vector len 0))
  (dotimes (i (1+ len))
    (setq str (char-to-string (+ ?a i))
          hash (% (hash-string str) len))
    (message "I put %s in slot %d"
             str hash)
    (if (eq (aref foo hash) 0)
        (intern str foo)
      (message "I found %S is already taking the slot: %S"
               (aref foo hash) foo)
      (intern str foo)
      (message "Now I'am in the slot too: %S" foo))))

在我这里的输出是：

I put a in slot 7
I put b in slot 8
I put c in slot 9
I put d in slot 0
I put e in slot 1
I put f in slot 2
I put g in slot 3
I put h in slot 4
I put i in slot 5
I put j in slot 6
I put k in slot 7
I found a is already taking the slot: [d e f g h i j a b c]
Now I'am in the slot too: [d e f g h i j k b c]

当然，这个 hash-string 和实际 obarray 里用的 hash-string 只是算法上是
相同的，但是由于数据类型和 c 不是完全相同，所以对于长一点的字符串结果
可能不一样，我只好用单个字符来演示一下。

plist-get 和 plist-put 的实现

(defun my-plist-get (plist prop)
  (cadr (memq plist prop)))
(defun my-plist-put (plist prop val)
  (let ((tail (memq prop plist)))
    (if tail
        (setcar (cdr tail) val)
      (setcdr (last plist) (list prop val))))
  plist)

my-plist-put 函数没有 plist-put 那样 robust，如果属性列表是 '(bar t
foo) 这样的话，这个函数就会出错。而且加入一个属性的时间复杂度比 plist
更高（memq 和 last 都是 O(n)），不过可以用循环来达到相同的时间复杂度。

** 求值规则
至此，elisp 中最常见的数据类型已经介绍完了。我们可以真正开始学习怎样写
一个 elisp 程序。如果想深入了解一下 lisp 是如何工作的，不妨先花些时间
看看 lisp 的求值过程。当然忽略这一部分也是可以的，因为我觉得这个求值规
则是那么自然，以至于你会认为它就是应该这样的。

求值是 lisp 解释器的核心，理解了求值过程也就学会了 lisp 编程的一半。正
因为这样，我有点担心自己说得不清楚或者理解错误，会误导了你。所以如果真
想深入了解的话，还是自己看 info elisp - Evaluation 这一章吧。

一个要求值的 lisp 对象被称为表达式（form）。所有的表达式可以分为三种：
符号、列表和其它类型（废话）。下面一一说明各种表达式的求值规则。

第一种表达式是最简单的，自求值表达式。前面说过数字、字符串、向量都是自
求值表达式。还有两个特殊的符号 t 和 nil 也可以看成是自求值表达式。

第二种表达式是符号。符号的求值结果就是符号的值。如果它没有值，就会出现
void-variable 的错误。

第三种表达式是列表表达式。而列表表达式又可以根据第一个元素分为函数调用
、宏调用和特殊表达式（special form）三种。列表的第一个表达式如果是一个
符号，解释器会查找这个表达式的函数值。如果函数值是另一个符号，则会继续
查找这个符号的函数值。这称为“symbol function indirection”。最后直到某
个符号的函数值是一个 lisp 函数（lambda 表达式）、byte-code 函数、原子
函数（primitive function）、宏、特殊表达式或 autoload 对象。如果不是这
些类型，比如某个符号的函数值是前面出现的某个符号导致无限循环，或者某个
符号函数值为空，都会导致一个错误 invalid-function。

这个函数显示 indirection function：

(symbol-function 'car)                  ; => #<subr car>
(fset 'first 'car)                      ; => car
(fset 'erste 'first)                    ; => first
(erste '(1 2 3))                        ; => 1

对于第一个元素是 lisp 函数对象、byte-code 对象和原子函数时，这个列表也
称为函数调用（funtion call）。对这样的列表求值时，先对列表中其它元素先
求值，求值的结果作为函数调用的真正参数。然后使用 apply 函数用这些参数
调用函数。如果函数是用 lisp 写的，可以理解为把参数和变量绑定到函数后，
对函数体顺序求值，返回最后一个 form 的值。

如果第一个元素是一个宏对象，列表里的其它元素不会立即求值，而是根据宏定
义进行扩展。如果扩展后还是一个宏调用，则会继续扩展下去，直到扩展的结果
不再是一个宏调用为止。例如：

(defmacro cadr (x)
  (list 'car (list 'cdr x)))

这样 (cadr (assq 'handler list)) 扩展后成为 (car (cdr (assq 'handler
list)))。

第一个元素如果是一个特殊表达式时，它的参数可能并不会全求值。这些特殊表
达式通常是用于控制结构或者变量绑定。每个特殊表达式都有对应的求值规则。
这在下面会提到。

最后用这个伪代码来说明一下 elisp 中的求值规则：

(defun (eval exp)
  (cond
   ((numberp exp) exp)
   ((stringp exp) exp)
   ((arrayp exp) exp)
   ((symbolp exp) (symbol-value exp))
   ((special-form-p (car exp))
    (eval-special-form exp))
   ((fboundp (car exp))
    (apply (car exp) (cdr exp)))
   (t
    (error "Unknown expression type -- EVAL %S" exp))))

** built-in fucn

1 make-sparse-keymap
	* Function: make-sparse-keymap &optional prompt
	* This function creates and returns a new sparse keymap 
with no entries. The new keymap does not contain a char-table, 
unlike make-keymap, and does not bind any events. The argument 
prompt specifies a prompt string, as in make-keymap.

** 私有函数
*** dump-vars-to-file

(defun dump-vars-to-file (varlist filename)
  "simplistic dumping of variables in VARLIST to a file FILENAME"
  (save-excursion
    (let ((buf (find-file-noselect filename)))
      (set-buffer buf)
      (erase-buffer)
      (dump varlist buf)
      (save-buffer)
      (kill-buffer))))

(defun dump (varlist buffer)
  "insert into buffer the setq statement to recreate the variables in VARLIST"
  ;; (loop for var in varlist do
  (dolist (var varlist)
        (print (list 'setq var (list 'quote (symbol-value var)))
               buffer)))
*** dolist-if

(defmacro dolist-if ( pair condtion body)
  (list 'let '(result)
        (list 'dolist  (append pair '(result))
              (list 'if condtion
                    (list 'setq 'result 
                          (list 'append 'result 
                                (list 'list 
                                      (list 'progn
                                            body))))))))

增加了条件过滤。格式是
(dolist-if (VAR LIST) COND BODY)
例如:
(dolist-if  (var '(1 2 3 4 5 6 7 8)) 
            (eq (% var 2) 0)
            (message var))
找出了所有的偶数


usage:

** 测试区

(setq a 0)
(a)
(hello)
(+ a 2)
(set 'flowers '(rose violet daisy buttercup))

flowers



单引号
   * 一个单引号标记, ', 告诉 lisp 解释器这应该返回写在后面的表达式，并且
     对之并不做求值，除非单引号不在.


(setq counter 0)
(setq counter (+ counter 2))
counter

(map (make-sparse-keymap)

(require 'tree-widget)
(defvar widget-tp-menu nil)
(unless widget-tp-menu
  (easy-menu-define
   widget-tp-menu widget-tp-mode-map "Widget Demo"
   `("Widget"
     ["Next Page" widget-tp-next t]
     ["Previous Page" widget-tp-previous t]
     ["Top" widget-tp t]
     ["Refresh" widget-tp-reflesh t]
     "--"
     ,@(mapcar (lambda (p)
                 (vector (car p) 'widget-tp-menu-goto t))
               widget-tp-list))))

`(usdx eur chf)
'(1hr 4hr day)

(setq foo "myfoo")
(put 'foo 'doc "this is abc")      ; => "this is abc"
(put 'foo 'joc "joc hah")      ; => "this is abc"
(symbol-plist 'foo)


(setq sym '("usdx" "eur" "gbp" "chf" "aud" "cad" "jpy"))
(setq tf '("1hr" "4hr" "day" "wek" "mon"))
(setq zk  '("obj" "sub"))

(dolist (s sym))

(dolist (s sym)
(dolist (f tf)
(dolist (d zk)
(set (intern (concat s "-" f "-" d)) "n")
)))




(mapc 'intern (mapcar (lambda(p) (concat "cc" p)) sym))
(intern-soft "ccusdx")
ccusdx

;; (widget-create  `(tree-widget 
		  ;; :node   (push-button :format "%[%t%]\n" :tag "每日功课")
		  ;; :open t
		  ;; (tree-widget
		    ;; ;; :node (push-button :format "%[%t%]\n" :tag "市场整体情况")
		    ;; :open nil
		    ;; ;; (push-button :format ,(formc "usdx") :tag "美元指数" :notify (lambda (widget &rest ignore)
										   ;; ;; (message "%s is a good choice!"
											    ;; ;; widget)))
		    ;; (push-button :format ,(formc "eur") :tag "欧元指数")
		    ;; (push-button :format "%[%t%]\n" :tag "node2")
		    ;; (choice-item "hello")
		    ;; )
		  ;; ))
;; (widget-setup)
;; (widget-create 'menu-choice
	       ;; :tag "menuchoice"
	       ;; :value "This"
	       ;; :help-echo "xxxjjjj"
	       ;; :notify (lambda(widget &rest ignore)
			 ;; (message "%s is a good choice!"
			 ;; (widget-value widget)))
	       ;; '(item :tag "This option" :value "This")
	       ;; '(choice-item "xxxalskdjf")
	       ;; '(editable-field :menu-tag "no option" "thus option")
	       ;; )menuchoice: This option

;; menuhoice: This option

p;; (setq q "xxx")


;; (defun formc (arg_sym)
  ;; (let ((hder "") (objb "") (subb ""))
    ;; (dolist (s tf)
      ;; (setq hder  (concat hder " | " s))
      ;; (setq objb  (concat objb " | " q))
      ;; (setq subb  (concat subb " | " "N/A"))
      ;; )
    ;; ;; (format "%%[%%t%%]\n%%[%s%%]\t%s |\nobj\t\%s |\nsub\t%s |\n "  arg_sym hder objb subb)
    ;; )
;; )

;; (formc "usdx")

;; print tf


;; (defmacro tflat()
  ;; ("haha")
;; )


;; (list "haha" "heihei" "haha")


   ;; dolist (tn '("node1" "node2"))
     ;; (push-button :format "%[%t%]\n" :tag tn)
;; (dolist (tn '("node1" "node2" "hha") bar)
  ;; (message "hello %s" tn)
;; )

;; (append [a b] "cd")  

;; (plist-get (assoc "Contents" tp-main-list) :header)

;; (defun tp-main-tree ()
  ;; (widget-insert "Tree:\n")
  ;; (widget-create
   ;; '(tree-widget
     ;; :node (push-button :format "%[%t%]\n" :tag "hello")
     ;; :open t
     ;; (push-button :format "%[%t%]\n" :tag "node1")
     ;; (push-button :format "%[%t%]\n" :tag "node2"))))
;; (widget-demo-tree-test)


;; (defun init-tp-tree()
  ;; (let (list))
;; )


;; ;; (dolist (s sym)
  ;; ;; (dolist (f tf)
    ;; ;; (put (intern (concat  s "-" f) tplan) 'obj "N/A")
    ;; ;; (put (intern (concat  s "-" f) tplan) 'sub "N/A")
;; ;; ))


;; (get (tp "usdx" "1hr") 'obj)


;; (get (intern "usdx-1hr" tplan) 'obj)
;; (get (tp "usdx-1hr") 'obj)
;; (get (intern "usdx-1hr" tplan) 'obj)

;; (defun print-syms (s)
;; (message "symbol %s" s)
;; )

;; (mapatoms 'print-syms tplan)


;; (defun drawtable()
  ;; (interactive)
  ;; (print "hello")
;; )

;; (drawtable)

;; (get 'usdx-1hr (car zk))


(fset (intern "abc" foo) (symbol-function 'car)) ; => #<subr car>
(funcall (intern "abc" foo) '(a . b))            ; => a

(fset (intern "abc" foo))


(setq a 10)
(put 'a 'func1 (message "hello"))
(put 'a 'func2 (message "hahaha"))


